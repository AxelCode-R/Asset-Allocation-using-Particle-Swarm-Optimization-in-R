```{r, include=FALSE}
source("global.R")
```

# Challenges of Passiv Investing

In this Chapter we will discuss two common challenges of Passiv-Investing and create simple examples to test the PSO. The first one is the mean-variance portfolio (MVP) from the modern portfolio theory of Markowitz which is simply said an optimal allocation of assets regarding risk and return. The second challenge is the index-tracking-problem which tries to construct a portfolio which has a minimal tracking error to a given benchmark.

## Mean-variance portfolio (MVP)
Markowitz has shown that diversifying the risk on multiple assets will reduce the overall risk of the portfolio. This result was the beginning of the widely used modern portfolio theorie which uses mathematical models to archive portfolios with minimal variance for a given return target. All these optimal portfolios for a given return target are called efficient and create the efficient frontier. 

### MVP calculation
We have $N$ assets and its returns on $T$ diffrent days which creates a return matrix $R$. Each element $R_{t,i}$ contains the return of the $i$-th asset on day $t$. The covariance matrix of the returns is $\textstyle\sum$ and the expected returns are $\mu$. The MVP with risk aversion parameter $\lambda$ like shown in [@Mar2005] minimizes the following problem:

`file:///C:/Users/Axel/Desktop/Master-Thesis-All/Ziel%20was%20beantwortet%20werden%20soll/Quellen%20nur%20wichtige/Maringer2005_Book_PortfolioManagementWithHeurist.pdf`
`https://bookdown.org/shenjian0824/portr/port-opt.html`
\begin{equation} 
\underset{w}{minimize} \ \ \ \lambda \ w^T \textstyle\sum w - (1-\lambda) \ w^T\mu
(\#eq:MVP)
\end{equation} 

The risk aversion parameter $\lambda$ defines the trade-off between risk and return. $\lambda = 1$ results in a minimum variance portfolio and $\lambda = 0$ results in a maximum return portfolio. All possible $\lambda \in [0, 1]$ represent the efficient frontier.



### MVP example
We will analyse a small example to understand the meaning of the efficient frontier without going into detail how it was solved. First of all we are pulling the daily returns of 3 tickers (IBM, Google and Apple). 
```{r}
returns <- get_prices_and_returns_av(choosen_tickers = c("IBM", "GOOG", "AAPL"), min_date = as.Date("2020-01-01"), max_date = as.Date("2021-01-01"))[["daily_returns"]]

plotly_line_chart_xts(ret_to_cumret(returns))
```
Now we can calculate the expected daily returns and the covariance matrix for the 3 assets:
```{r}
mu <- as.vector((last(ret_to_cumret(returns))/100)^(1/nrow(returns))-1)
mu

cov <- as.matrix(nearPD(cov(returns))$mat)
cov
```
At this moment we have all the needed data to solve the MVP \@ref(eq:MVP) with $\lambda \in \{0.01, 0.02, ..., 0.99, 1\}$. Afterwords we calculate the annual returns and standard deviation and draw the efficient frontier and the composition of the portfolios:

```{r, echo=F, warning=F, message=F}
portfolios <- data.frame()
mu_and_var <- NULL
for(lambda in seq(0.01,1, 0.01)){
    mat <- list(
      Dmat = lambda * cov,
      dvec = (1 - lambda) * mu,
      Amat = t(rbind(
        rep(1, ncol(returns)), # sum up to 1
        diag(1, nrow=ncol(returns), ncol=ncol(returns)) # long only
      )),
      bvec = c(
        1, # sum up to 1
        rep(0, ncol(returns)) # long only
      ),
      meq = 1
    )
    
    qp <- solve.QP(Dmat = mat$Dmat, dvec = mat$dvec, Amat = mat$Amat, bvec = mat$bvec, meq = mat$meq)
    
    port <- xts(returns %*% qp$solution, order.by=index(returns))
    
    mu_and_var <- rbind(
      mu_and_var,
      data.frame("lambda" = lambda, "mu" = mu %*% qp$solution, "sd" = sqrt(t(qp$solution) %*% cov %*% qp$solution))
    )
    portfolios <- rbind(
      portfolios,
      qp$solution
    )
}
portfolios <- data.frame(portfolios)
colnames(portfolios) <- colnames(returns)

# annualize
mu_and_var$mu <- (1+mu_and_var$mu)^252-1
mu_and_var$sd <- mu_and_var$sd * sqrt(252)

plot_ly(data = mu_and_var) %>% 
  add_lines(y = ~mu, x = ~sd, name = "efficient frontier") %>% 
  add_trace(x = ~sd, y=~mu, mode="markers", name = "lambda steps") %>% 
  layout(
    title = "3-Asset MVP",
    yaxis = list(range=c(min(mu_and_var$mu)*0.9, max(mu_and_var$mu)*1.1)),
    xaxis = list(range=c(min(mu_and_var$sd)*0.95, max(mu_and_var$sd)*1.05)),
    margin = list(
        l = 10,
        r = 10,
        b = 70,
        t = 50,
        pad = 4
    )
  ) 

p <- plot_ly(type="bar") %>% layout(title="Portfolio compositions", barmode="stack", xaxis = list(title="lambda", autorange = "reversed"), yaxis = list(title="wgt"))
for(i in 1:ncol(portfolios)){
  p <- p %>% 
  add_trace(x=seq(0.01,1, 0.01), y=portfolios[, i], name = colnames(portfolios)[i])
}
p

```


## Index-tracking portfolio (ITP)












