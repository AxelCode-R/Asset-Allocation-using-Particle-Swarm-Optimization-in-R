---
output:
  html_document: default
  pdf_document: default
---
```{r, include=FALSE, echo=FALSE}
source("global.R")
# knitr::opts_chunk$set(fig.width=8, fig.height=4)
# bookdown::preview_chapter(input="2_Challenges_of_Passiv_Investing.Rmd")
```

# Challenges of Passiv Investing

In this Chapter we will discuss two common challenges of Passiv-Investing and create simple examples to test the PSO. The first one is the mean-variance portfolio (MVP) from the modern portfolio theory of Markowitz which is simply said an optimal allocation of assets regarding risk and return. The second challenge is the index-tracking-problem which tries to construct a portfolio which has a minimal tracking error to a given benchmark.

## Mean-variance portfolio (MVP)
Markowitz has shown that diversifying the risk on multiple assets will reduce the overall risk of the portfolio. This result was the beginning of the widely used modern portfolio theorie which uses mathematical models to archive portfolios with minimal variance for a given return target. All these optimal portfolios for a given return target are called efficient and create the efficient frontier. 

### MVP calculation
We have $N$ assets and its returns on $T$ diffrent days which creates a return matrix $R$. Each element $R_{t,i}$ contains the return of the $i$-th asset on day $t$. The covariance matrix of the returns is $\textstyle\sum$ and the expected returns are $\mu$. The MVP with risk aversion parameter $\lambda$ like shown in [@Mar2005] minimizes the following problem:

`file:///C:/Users/Axel/Desktop/Master-Thesis-All/Ziel%20was%20beantwortet%20werden%20soll/Quellen%20nur%20wichtige/Maringer2005_Book_PortfolioManagementWithHeurist.pdf`
`https://bookdown.org/shenjian0824/portr/port-opt.html`
\begin{equation} 
\underset{w}{minimize} \ \ \ \lambda \ w^T \textstyle\sum w - (1-\lambda) \ w^T\mu
(\#eq:MVP)
\end{equation} 

The risk aversion parameter $\lambda$ defines the trade-off between risk and return. $\lambda = 1$ results in a minimum variance portfolio and $\lambda = 0$ results in a maximum return portfolio. All possible $\lambda \in [0, 1]$ represent the efficient frontier.



### MVP example
We will analyse a small example to understand the meaning of the efficient frontier without going into detail how it was solved. First of all we are pulling the daily returns of 3 tickers (IBM, Google and Apple). 
```{r, fig.asp=0.5, cache=TRUE}
returns <- buffer(
  get_yf(tickers = c("IBM", "GOOG", "AAPL"), from = "2020-01-01", to = "2021-01-01")$returns, 
  "3_assets"
)


p <- plotly_line_chart_xts(ret_to_cumret(returns))

htmlwidgets::saveWidget(p, "p.html")
webshot2::webshot("p.html", "p.png", delay=1, zoom=4, vheight=300, vwidth = 600)
```
Now we can calculate the expected daily returns and the covariance matrix for the 3 assets:
```{r}
mu <- as.vector((last(ret_to_cumret(returns))/100)^(1/nrow(returns))-1)
mu

cov <- as.matrix(nearPD(cov(returns))$mat)
cov
```
At this moment we have all the needed data to solve the MVP \@ref(eq:MVP) with $\lambda \in \{0.01, 0.02, ..., 0.99, 1\}$. Afterwords we calculate the annual returns and standard deviation and draw the efficient frontier and the composition of the portfolios:

```{r, echo=F, warning=F, message=F, fig.width=8, cache=TRUE}
portfolios <- data.frame()
mu_and_var <- NULL
for(lambda in seq(0.01,1, 0.01)){
    mat <- list(
      Dmat = lambda * cov,
      dvec = (1 - lambda) * mu,
      Amat = t(rbind(
        rep(1, ncol(returns)), # sum up to 1
        diag(1, nrow=ncol(returns), ncol=ncol(returns)) # long only
      )),
      bvec = c(
        1, # sum up to 1
        rep(0, ncol(returns)) # long only
      ),
      meq = 1
    )

    qp <- solve.QP(Dmat = mat$Dmat, dvec = mat$dvec, Amat = mat$Amat, bvec = mat$bvec, meq = mat$meq)

    port <- xts(returns %*% qp$solution, order.by=index(returns))

    mu_and_var <- rbind(
      mu_and_var,
      data.frame("lambda" = lambda, "mu" = mu %*% qp$solution, "sd" = sqrt(t(qp$solution) %*% cov %*% qp$solution))
    )
    portfolios <- rbind(
      portfolios,
      qp$solution
    )
}
portfolios <- data.frame(portfolios)
colnames(portfolios) <- colnames(returns)

# annualize
mu_and_var$mu <- (1+mu_and_var$mu)^252-1
mu_and_var$sd <- mu_and_var$sd * sqrt(252)

plot_ly(data = mu_and_var) %>%
  add_lines(y = ~mu, x = ~sd, name = "efficient frontier") %>%
  add_trace(x = ~sd, y=~mu, mode="markers", name = "lambda steps") %>%
  layout(
    title = "3-Asset MVP",
    yaxis = list(range=c(min(mu_and_var$mu)*0.9, max(mu_and_var$mu)*1.1)),
    xaxis = list(range=c(min(mu_and_var$sd)*0.95, max(mu_and_var$sd)*1.05)),
    margin = list(
        l = 10,
        r = 10,
        b = 70,
        t = 50,
        pad = 4
    )
  )

p <- plot_ly(type="bar") %>% layout(title="Portfolio compositions", barmode="stack", xaxis = list(title="lambda", autorange = "reversed"), yaxis = list(title="wgt"))
for(i in 1:ncol(portfolios)){
  p <- p %>%
  add_trace(x=seq(0.01,1, 0.01), y=portfolios[, i], name = colnames(portfolios)[i])
}
p

```


## Index-tracking portfolio (ITP)
Indices are baskets of assets which are used to track the performance of a specific group of assets. For example tracks the good known Standard and Poor's 500 index (short: S&P 500) the largest 500 equitys in the United States. All indices are not investible and only serve for the visualisation of the performance of these groups of assets without transaction costs. Asset managements adopted these indices as benchmarks to compare there fund performances. Each fund has its own benchmark which contains roughly the same assets that could be purchased by the manager. If the fund under performs his benchmark, it could be a indicator for a bad decision from the fund manager. Thats why all fund managers are eager to beat there benchmarks with wisely choosen investments. The past has proven that this is rearly achived with activ managemnt after costs (quelle studie activ passiv). This is the reason why passiv managed funds with the goal to track there benchmarks are becoming more frequent. Exactly this can be archived with Index-tracking portfolios (ITP) which aim to replicate the performance of a benchmark. This can be done by either full-replication or sparse-replication. A full-replication, which produces the exact performance we aim for, isn't possible in most cases because not all assets of a index are investable. And if so it wouldnt be wise because benchmarks with multiple indices can contain more than ten thousand single assets which will produce a huge amount of transaction costs. The most common way to go is a sparse replication of the performance. To do so the portfolio manager has to define his benchmark which has a overlap with his investment universe of his fund. Afterwards he will reduce this universe by some rules of the investor, liqudity and availability. Now he can start to optimize a portfolio, including the investors constraint, to replicate the benchmark performance. Usually, this is done by reducing the difference between the daily returns of the ITP and the benchmark:

$$
 minimize \ \ Var(r_{p}-r_{bm})
$$
First we need to substitude $r_{p}$ to get the portfolio weights $w$ as follows:
$$
  r_{p} = R * w
$$
Afterwards we solve the Variance until it is displayed as a quadratic problem of $w$:
$$
 Var(r_{p}-r_{bm}) = Var(R * w - r_{bm}) = Var(R * w) + Var(r_{bm}) - 2 \cdot Cov(R*w,r_{bm}) 
$$
Now we need to solve each of the 3 terms, startign with the simplest

$$
Var(r_{bm}) = \sigma_{bm}^2 = constant
$$

The variance of the portfolio can be solved by looking at the proof in [http://www.math.kent.edu/~reichel/courses/monte.carlo/alt4.7d.pdf (proof auch selber machen)] at the linear combination of random variables section:
$$
Var(R * w) = w^T * Cov(R) * w
$$

And the last term can be solved in general as (https://bookdown.org/compfinezbook/introcompfinr/Multivariate-Probability-Distributions-Using-Matrix-Algebra.html 3.6.5):
$$
  Cov(A*a, b) = Cov(b, A*a) = E[(b-\mu_{b})(A*a-\mu_{A}*a)] = E[(b-\mu_{b})(A-\mu_{A})*a] = E[(b-\mu_{b})(A-\mu_{A})]*a = Cov(A,b) * a
$$

```{r}
A = matrix(c(1,4,2,4,6,3,8,4,4,10), ncol=2)
a = c(0.2, 0.8)
b = c(4,4,5,5,7)

cov(A %*% a, b)
t(a) %*% cov(A, b)
t(cov(A, b)) %*% a # das hier wird gebraucht

```

This results in the final formula of the ITP:

\begin{equation}
  \begin{split}
   Var(r_{p}-r_{bm}) & = Var(R \times w - r_{bm}) \\
   & = Var(R \times w) - 2 \cdot Cov(R \times w,r_{bm}) + Var(r_{bm})  \\
   & = w^T \times Cov(R) \times w - 2 \cdot Cov(r_{bm}, R)^T \times w + \sigma_{bm}^2
   \end{split}
   (\#eq:ITP)
\end{equation}

The minimization problem of the ITP in the general stricture which all optimizers need is:
$$
  min(\frac{1}{2} \cdot b^T \times D \times b -d^T \times b)
$$
Because it is a minimization we can ignore constant terms and stretching coefficients and still find the same minimum. This results in the general substitution of the ITP as follows:
$$
  D = Cov(R)
$$
and
$$
d = Cov(r_{bm}, R)
$$

Now we need to add some basic constraints like in the MVP, to sum up the weights to 1 and being long only. 

### Example ITP
We will show the results of tracking the S&P 500 with a tracking portfolio that can only invest in IBM, Apple and Google without going into details:
222233333344445
```{r, echo = knitr::is_html_output(), class.source="code_fold_it_collapsed"}
pool_returns <- buffer(
  get_yf(tickers = c("IBM", "GOOG", "AAPL"), from = "2020-01-01", to = "2021-01-01")$returns, 
  "3_assets"
)

bm_returns <- buffer(
  setNames(get_yf(tickers = "%5EGSPC", from = "2020-01-01", to = "2021-01-01")$returns, "S&P 500"), 
  "sp500"
)


mat <- list(
    Dmat = cov(pool_returns),
    dvec = cov(pool_returns, bm_returns),
    Amat = t(rbind(
      rep(1, ncol(pool_returns)), # sum up to 1
      diag(1, nrow=ncol(pool_returns), ncol=ncol(pool_returns)) # long only
    )),
    bvec = c(
      1, # sum up to 1
      rep(0, ncol(pool_returns)) # long only
    ),
    meq = 1
)

qp <- solve.QP(Dmat = mat$Dmat, dvec = mat$dvec, Amat = mat$Amat, bvec = mat$bvec, meq = mat$meq)

port_returns <- xts(pool_returns %*% qp$solution, order.by=index(pool_returns)) %>% setNames(., "tracking portfolio")

p <- plotly_line_chart_xts(ret_to_cumret(cbind.xts(port_returns, bm_returns)))

setNames(qp$solution, colnames(pool_returns))
```

```{r, echo = F}
htmlwidgets::saveWidget(p, "p2.html")
webshot2::webshot("p2.html", "p2.png", delay=1, zoom=4, vheight=300, vwidth = 600)
```





```{r, echo=FALSE, results='asis'}
cat(paste0("<style> \n",paste0(readr::read_lines("my_style.css"), collapse = " \n")," </style>"))
cat(paste0("<script type='text/javascript'> \n",paste0(readr::read_lines("script.js"), collapse = " \n")," </script>"))
```
