[["index.html", "Master-Thesis Preface", " Master-Thesis Axel Roth 2022-08-14 Preface Blah blah blah "],["abstract.html", "Chapter 1 Abstract", " Chapter 1 Abstract Things about this thesis. why and what question should be answered. and what are the answers. (zusammenfassung) "],["software-information-and-usage.html", "Chapter 2 Software information and usage 2.1 R-Version and Packages 2.2 reproducibility 2.3 R-functions", " Chapter 2 Software information and usage wie ich das buch schreibe, R markodwn bookdown und so und welche versionen ich nutze 2.1 R-Version and Packages 2.2 reproducibility github und code im bookdown 2.3 R-functions zb plotly_save "],["open-data-sources.html", "Chapter 3 Open Data Sources 3.1 R-functions", " Chapter 3 Open Data Sources yahoo finance 3.1 R-functions "],["mathematical-fundations.html", "Chapter 4 Mathematical Fundations 4.1 Basic Operators 4.2 Return calculation 4.3 Markowitz Modern Portfolio Theory (MPT) 4.4 Portfolio Math", " Chapter 4 Mathematical Fundations This chapter provides an overview of the mathematical calculations and conventions used in this Thesis. Its important to note that the majority of mathematical formulas are written in matrix notation. In the majority of cases, this will result in a direct translation into R-code. We also provide all necessary assumptions for the modeled return structure. It is crucial to note that reality is too complicated and can only be partially modeled. We employ simplistic, basic models that dont hold up in real-world situations, but these models or variations on them are frequently used in finance and have proven to be helpful. Additionally, because factor models commonly reduce the dimension of the modeled dependencies, these fundamental models result in more complex problems for the PSO to solve. 4.1 Basic Operators A compendium that compares commonly used mathematical symbols to R-code and its meanings can be found in the table below: 4.2 Return calculation Any portfolio optimization strategy based on historical data must start with returns. These returns are calculated using adjusted closing prices, which show the percentage change over time. Adjusted closing prices are reflecting dividends and are cleaned of by stock splits and rights offerings. These Returns are essential for comparing assets and for analyzing dependencies. 4.2.1 daily returns The default timeframe for all raw data in this thesis is one workday, and we only use simple returns. The simple returns can be calculated as follows if we know the adjusted closing price \\(P\\) of one asset on workdays \\(t_i\\) and \\(t_{i+1}\\): \\[ R_{i+1} = \\frac{P_{t_{i+1}}}{P_{t_i}}-1 \\] 4.2.2 annualized returns 4.3 Markowitz Modern Portfolio Theory (MPT) In 1952, Harry Markowitz published his first ground-breaking work, which had a significant influence on modern finance. primarily by outlining the effects of diversification and efficient portfolio. The definition of an efficient portfolio is one that has either the maximum expected return for a given risk target or the minimum risk for the given expected return. A portfolio has the same return but less variance than the sum of its parts is a simple definition of diversification. This is true if the assets are not perfectly correlated because bad and good movers can make up for each other, reducing the likelihood of extreme events. You can find more specific information at (Maringer 2005). 4.3.1 Assumptions of Markowitz Portfolio Theory The following are the Markowitz assumptions that can be combined, according to (Maringer 2005): It is not necessary to assume that the returns are normally distributed, but we will use it here, to simplify the problem. More information about the conditions for using other distributions can be found in (Maringer 2005). It is clear that these assumption do not hold in practice. The assumption that the returns are normally distributed is not required, but well assume it in this case to make the problem simpler. (Maringer 2005) has further details regarding the requirements for utilizing other distributions. It is obvious that these assumptions are unrealistic in practice. 4.4 Portfolio Math Proofs for the fundamental calculations required for portfolio optimization as shown in (Zivot 2021) will be provided in this section. Im hoping that everyone who reads this will be able to comprehend the formulas in their entirety. Since this is the most widely used data format in practice, we prefer to represent the returns differently than most sources. The portfolio weights for \\(N\\) assets are denoted by \\(w\\) and the random return vector \\(R\\), respectively: \\[ R = \\begin{bmatrix} R_{1} &amp; R_{2} &amp; \\cdots &amp; R_{N} \\end{bmatrix} , \\ \\ w = \\begin{bmatrix} w_{1} \\\\ w_{2} \\\\ \\cdots \\\\ w_{N} \\end{bmatrix} \\] In this thesis, we also simplify each return to be normally distributed with \\(R_i = \\mathcal{N}(\\mu_i, \\sigma_i^2)\\). As a result, linear combinations of normally distributed random variables are jointly normal distributed and have a mean, variance, and covariance that can be used to fully describe them. 4.4.1 expected returns The following formula can be used to get the expected returns of a vector with normally distributed random variables \\(R \\in \\mathbb{R}^{N}\\): \\[ E[R] = \\begin{bmatrix} E[R_{1}] &amp; E[R_{2}] &amp; \\cdots &amp; E[R_{N}] \\end{bmatrix} = \\begin{bmatrix} E[\\mu_{1}] &amp; E[\\mu_{2}] &amp; \\cdots &amp; E[\\mu_{N}] \\end{bmatrix} = \\mu \\] ### expected portfolio return The following equation can be used to get the linear combination of expected returns \\(mu\\) and a weighting vector \\(w\\) (for example, portfolio weights): \\[ \\mu \\times w = \\begin{bmatrix} E[\\mu_{1}] &amp; E[\\mu_{2}] &amp; \\cdots &amp; E[\\mu_{N}] \\end{bmatrix} \\times \\begin{bmatrix} w_{1} \\\\ w_{2} \\\\ \\cdots \\\\ w_{N} \\end{bmatrix} = E[\\mu_{1}] \\cdot w_1 + E[\\mu_{2}] \\cdot w_2 + \\cdots + E[\\mu_{N}] \\cdot w_{N} = \\mu_P \\] 4.4.2 portfolio returns Let \\(R \\in \\mathbb{R}^{T \\times N}\\) denote a realized return Matrix of \\(N\\) assets and \\(T\\) days in the past. The portfolio return on each day can be calculated with the formula of the expected portfolio return. This is possible on all days \\(T\\) by: \\[ R \\times w = \\begin{bmatrix} R_{1, 1} &amp; R_{1, 2} &amp; \\cdots &amp; R_{1, N} \\\\ R_{2, 1} &amp; R_{2, 2} &amp; \\cdots &amp; R_{2, N} \\\\ \\cdots \\\\ R_{T, 1} &amp; R_{T, 2} &amp; \\cdots &amp; R_{T, N} \\\\ \\end{bmatrix} \\times \\begin{bmatrix} w_{1} \\\\ w_{2} \\\\ \\cdots \\\\ w_{N} \\end{bmatrix} = \\begin{bmatrix} R_{1}^P \\\\ R_{2}^P \\\\ \\cdots \\\\ R_{N}^P \\end{bmatrix} = R_P \\] References "],["activ-vs-passiv-investing.html", "Chapter 5 Activ vs Passiv Investing", " Chapter 5 Activ vs Passiv Investing The fundation of each Asset Management passiv vs activ studie https://www.scirp.org/journal/paperinformation.aspx?paperid=92983 gut gut file:///C:/Users/Axel/Desktop/Master-Thesis-All/Ziel%20was%20beantwortet%20werden%20soll/Quellen%20nur%20wichtige/Rasmussen2003_Book_QuantitativePortfolioOptimisat.pdf "],["challenges-of-passiv-investing.html", "Chapter 6 Challenges of Passiv Investing 6.1 Mean-variance portfolio (MVP) 6.2 Index-tracking portfolio (ITP)", " Chapter 6 Challenges of Passiv Investing In this Chapter we will discuss two common challenges of Passiv-Investing and create simple examples to test the PSO. The first one is the mean-variance portfolio (MVP) from the modern portfolio theory of Markowitz which is simply said an optimal allocation of assets regarding risk and return. The second challenge is the index-tracking-problem which tries to construct a portfolio which has a minimal tracking error to a given benchmark. 6.1 Mean-variance portfolio (MVP) Markowitz has shown that diversifying the risk on multiple assets will reduce the overall risk of the portfolio. This result was the beginning of the widely used modern portfolio theorie which uses mathematical models to archive portfolios with minimal variance for a given return target. All these optimal portfolios for a given return target are called efficient and create the efficient frontier. 6.1.1 MVP We have \\(N\\) assets and its returns on \\(T\\) different days which creates a return matrix \\(R \\in \\mathbb{R}^{T \\times N}\\). Each element \\(R_{t,i}\\) contains the return of the \\(i\\)-th asset on day \\(t\\). The covariance matrix of the returns is \\(\\textstyle\\sum \\in \\mathbb{R}^{N \\times N}\\) and the expected returns are \\(\\mu \\in \\mathbb{R}^{N}\\). The MVP with risk aversion parameter \\(\\lambda \\in [0,1]\\) like shown in (Maringer 2005) can be formalized as follows: \\[\\begin{equation} \\underset{w}{minimize} \\ \\ \\ \\lambda \\ w^T \\textstyle\\sum w - (1-\\lambda) \\ \\mu^T w \\tag{6.1} \\end{equation}\\] The risk aversion parameter \\(\\lambda\\) defines the trade-off between risk and return. With \\(\\lambda = 1\\), the minimization problem only contains the the variance term and so on results in a minimum variance portfolio and \\(\\lambda = 0\\) transforms the problem to a minimization of the negative expected returns so on results in a maximum return portfolio. All possible \\(\\lambda \\in [0, 1]\\) represent the efficient frontier. 6.1.2 MVP example We will analyze a small example to understand the meaning of the efficient frontier without going into detail how it was solved. First of all we are loading the daily returns of IBM, Google and Apple from the year 2020. returns &lt;- buffer( get_yf(tickers = c(&quot;IBM&quot;, &quot;GOOG&quot;, &quot;AAPL&quot;), from = &quot;2020-01-01&quot;, to = &quot;2020-12-31&quot;)$returns, &quot;3_assets&quot; ) The cumulated daily returns are: Now we can calculate the expected daily returns and the covariance matrix for the 3 assets: mu &lt;- as.vector((last(ret_to_cumret(returns))/100)^(1/nrow(returns))-1) %&gt;% setNames(., colnames(returns)) mu ## AAPL IBM GOOG ## 0.00237641721 -0.00004622149 0.00106873786 cov &lt;- as.matrix(nearPD(cov(returns))$mat) cov ## AAPL IBM GOOG ## AAPL 0.0008635696 0.0004356282 0.0005337719 ## IBM 0.0004356282 0.0006626219 0.0004086728 ## GOOG 0.0005337719 0.0004086728 0.0005827306 We now have all the necessary data to solve the MVP (6.1) with \\(\\lambda \\in \\{0.01, 0.02, ..., 0.99, 1\\}\\). We calculate all 100 portfolios by solving the quadratic minimization problem for each \\(\\lambda\\). portfolios &lt;- data.frame() mu_and_var &lt;- NULL for(lambda in seq(0.01,1, 0.01)){ mat &lt;- list( Dmat = lambda * cov, dvec = (1 - lambda) * mu, Amat = t(rbind( rep(1, ncol(returns)), # sum up to 1 diag(1, nrow=ncol(returns), ncol=ncol(returns)) # long only )), bvec = c( 1, # sum up to 1 rep(0, ncol(returns)) # long only ), meq = 1 ) qp &lt;- solve.QP(Dmat = mat$Dmat, dvec = mat$dvec, Amat = mat$Amat, bvec = mat$bvec, meq = mat$meq) port &lt;- xts(returns %*% qp$solution, order.by=index(returns)) mu_and_var &lt;- rbind( mu_and_var, data.frame(&quot;lambda&quot; = lambda, &quot;mu&quot; = mu %*% qp$solution, &quot;sd&quot; = sqrt(t(qp$solution) %*% cov %*% qp$solution)) ) portfolios &lt;- rbind( portfolios, qp$solution ) } portfolios &lt;- data.frame(portfolios) colnames(portfolios) &lt;- colnames(returns) Following that, we convert the daily returns and standard deviation to yearly returns and standard deviation before plotting the efficient frontier. # annualize mu_and_var$mu &lt;- (1+mu_and_var$mu)^250-1 mu_and_var$sd &lt;- mu_and_var$sd * sqrt(250) plot_ly(data = mu_and_var) %&gt;% add_lines(y = ~mu, x = ~sd, name = &quot;efficient frontier&quot;) %&gt;% add_trace(x = ~sd, y=~mu, mode=&quot;markers&quot;, name = &quot;lambda steps&quot;) %&gt;% layout( title = &quot;3-Asset MVP&quot;, yaxis = list(range=c(min(mu_and_var$mu)*0.9, max(mu_and_var$mu)*1.1)), xaxis = list(range=c(min(mu_and_var$sd)*0.95, max(mu_and_var$sd)*1.05)), margin = list( l = 10, r = 10, b = 70, t = 50, pad = 4 ) ) %&gt;% html_save() p &lt;- plot_ly(type=&quot;bar&quot;) %&gt;% layout(title=&quot;Portfolio compositions&quot;, barmode=&quot;stack&quot;, xaxis = list(title=&quot;lambda&quot;, autorange = &quot;reversed&quot;), yaxis = list(title=&quot;wgt&quot;)) for(i in 1:ncol(portfolios)){ p &lt;- p %&gt;% add_trace(x=seq(0.01,1, 0.01), y=portfolios[, i], name = colnames(portfolios)[i]) } p %&gt;% html_save() 6.2 Index-tracking portfolio (ITP) Indices are asset baskets that are used to track the performance of a specific asset group. The well-known Standard and Poors 500 index (short: S&amp;P 500), for example, tracks the top 500 stocks in the United States. All indices are not investible and only serve to visualize the performance of these asset groups without incurring transaction costs. Asset managers use such indices as benchmarks to compare the performance of their funds. Each fund has its own benchmark, which contains roughly the same assets that the manager could purchase. If the fund underperforms its benchmark, it may be an indication that the fund manager made a poor decision. That is why all fund managers strive to outperform their benchmarks through carefully chosen investments. The past has proven that this is rearly achived with activ managemnt after costs (Desmond Pace and Grima 2016). This is the reason why passiv managed funds with the goal to track there benchmarks are becoming more frequent. This is why passively managed funds with the purpose of tracking their benchmarks are becoming more common. This can be accomplished through either full or sparse replication. In most circumstances, a full replication that achieves the exact performance we seek is not achievable because not all assets in an index are investable. And, if so, it would be unwise because benchmarks with numerous indexes can contain over ten thousand separate assets, resulting in a massive amount of transaction costs. A sparse replication of the performance is the most prevalent approach. To do so, the portfolio manager must define his benchmark, which should overlap with his funds investing universe. Following that, he will reduce this universe using investor principles such as liquidity and availability. Now he can begin to optimize a portfolio, taking into account the investor constraints, in order to match the benchmark performance. Typically, this is accomplished by lowering the variance between the ITPs daily returns and the benchmark: \\[ minimize \\ \\ Var(r_{p}-r_{bm}) \\] To obtain the portfolio weights \\(w\\), we must first substitute \\(r_{p}\\) as shown below: \\[ r_{p} = R * w \\] The Variance is then solved up until a quadratic problem dependent on the portfolio weights \\(w\\) is represented: \\[ Var(r_{p}-r_{bm}) = Var(R * w - r_{bm}) = Var(R * w) + Var(r_{bm}) - 2 \\cdot Cov(R*w,r_{bm}) \\] We must now solve each of the three terms, beginning with the easiest. \\[ Var(r_{bm}) = \\sigma_{bm}^2 = constant \\] The variance of the portfolio can be solved by looking at the Portfolio math Using Matrix Algebra section in (Zivot 2021): \\[ Var(R * w) = w^T * Cov(R) * w \\] And the last term can be solved in general as (https://bookdown.org/compfinezbook/introcompfinr/Multivariate-Probability-Distributions-Using-Matrix-Algebra.html 3.6.5): \\[ Cov(A*a, b) = Cov(b, A*a) = E[(b-\\mu_{b})(A*a-\\mu_{A}*a)] = E[(b-\\mu_{b})(A-\\mu_{A})*a] = E[(b-\\mu_{b})(A-\\mu_{A})]*a = Cov(A,b) * a \\] A = matrix(c(1,4,2,4,6,3,8,4,4,10), ncol=2) a = c(0.2, 0.8) b = c(4,4,5,5,7) cov(A %*% a, b) ## [,1] ## [1,] 2.15 t(a) %*% cov(A, b) ## [,1] ## [1,] 2.15 t(cov(A, b)) %*% a # das hier wird gebraucht ## [,1] ## [1,] 2.15 This results in the final formula of the ITP: \\[\\begin{equation} \\begin{split} Var(r_{p}-r_{bm}) &amp; = Var(R \\times w - r_{bm}) \\\\ &amp; = Var(R \\times w) - 2 \\cdot Cov(R \\times w,r_{bm}) + Var(r_{bm}) \\\\ &amp; = w^T \\times Cov(R) \\times w - 2 \\cdot Cov(r_{bm}, R)^T \\times w + \\sigma_{bm}^2 \\end{split} \\tag{6.2} \\end{equation}\\] The minimization problem of the ITP in the general stricture which all optimizers need is: \\[ min(\\frac{1}{2} \\cdot b^T \\times D \\times b -d^T \\times b) \\] Because it is a minimization we can ignore constant terms and stretching coefficients and still find the same minimum. This results in the general substitution of the ITP as follows: \\[ D = Cov(R) \\] and \\[ d = Cov(r_{bm}, R) \\] Now we need to add some basic constraints like in the MVP, to sum up the weights to 1 and being long only. 6.2.1 Example ITP We will show the results of tracking the S&amp;P 500 with a tracking portfolio that can only invest in IBM, Apple and Google without going into details: pool_returns &lt;- buffer( get_yf(tickers = c(&quot;IBM&quot;, &quot;GOOG&quot;, &quot;AAPL&quot;), from = &quot;2020-01-01&quot;, to = &quot;2020-12-31&quot;)$returns, &quot;3_assets&quot; ) bm_returns &lt;- buffer( get_yf(tickers = &quot;%5EGSPC&quot;, from = &quot;2020-01-01&quot;, to = &quot;2020-12-31&quot;)$returns, &quot;sp500&quot; ) %&gt;% setNames(., &quot;S&amp;P 500&quot;) mat &lt;- list( Dmat = cov(pool_returns), dvec = cov(pool_returns, bm_returns), Amat = t(rbind( rep(1, ncol(pool_returns)), # sum up to 1 diag(1, nrow=ncol(pool_returns), ncol=ncol(pool_returns)) # long only )), bvec = c( 1, # sum up to 1 rep(0, ncol(pool_returns)) # long only ), meq = 1 ) qp &lt;- solve.QP(Dmat = mat$Dmat, dvec = mat$dvec, Amat = mat$Amat, bvec = mat$bvec, meq = mat$meq) port_returns &lt;- xts(pool_returns %*% qp$solution, order.by=index(pool_returns)) %&gt;% setNames(., &quot;tracking portfolio&quot;) setNames(qp$solution, colnames(pool_returns)) ## AAPL IBM GOOG ## 0.2677928 0.4041880 0.3280192 plotly_line_chart_xts(ret_to_cumret(cbind.xts(port_returns, bm_returns))) %&gt;% html_save() References "],["analytical_solver.html", "Chapter 7 Analytical_Solver", " Chapter 7 Analytical_Solver example to solve problems with analytical solvers "],["simple_particle_swarm_optimization.html", "Chapter 8 Simple_Particle_Swarm_Optimization", " Chapter 8 Simple_Particle_Swarm_Optimization first pso examples and explainations "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
