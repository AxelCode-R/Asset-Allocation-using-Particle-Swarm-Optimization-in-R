---
output:
  pdf_document: default
  html_document: default
editor_options:
  chunk_output_type: console
---
# Real Life ITP Example

(Vorhaben)
focus auf testphase legen, diskrete (20k), long only, 0<w<0.1, ITP S&P500 tracken mit weniger als 50 titeln und mehr als 30, vorauswahl von assetpool?, umschichtungs constraint, transaktionskosten 1 euro, 


The previous chapters have analyzed the capability's of a PSO and the quality of the results by solving a problem in a single timepoint. In practice, the stability of future results on multiple timepoints is of higher interest. Therefore the next sections provide additional constraints that are needed to simulate real portfolios over multiple rebalancing dates, starting by adding transaction costs to the problem. The first reblancing date will define a problem that simulates a portfolio manager that has a defined amount of cash and tries to construct a portfolio from it, like in the last chapter. After the first iteration the portfolio manager needs to sell old assets and buy new ones. Of course do this produce additional transaction costs and effort, which is why most portfolio managers consider a maximal rebalancing constraint, that tries to limit the amount of sold and bought assets. The simulation of multiple rebalancing dates is called a backtest, which tries to simulate the performance of a portfolio dependent on the previous portfolio and the historic data of each rebalancing date. Later the objective is analyzed more deeply with focus on the forecast ability. And at last a complete backtest of a ITP in a practice near setting is evaluated and analyzed.


## Transaction Costs
The costs to buy or sell assets needs to be considered, because it can have a huge impact after several years of investment. There are many different costs that can occur dependent on the concepts of the broker, liquidity of assets and types of assets. For more information have a look at [@AkGa2022] or [@NySe2022]. To keep it simple, we focus on the situation of a private investor using a online broker that has a fixed fee per transaction for US equity's contained in the S&P 500. Each transaction consists of one or multiple shares of one asset and a transaction can ether be a sell or a buy transaction. The fixed transaction fee is set on 1 USD like done by the online broker Trade Republic. The PSO can consider the transaction costs by increasing the objective value. It is difficult to make the intensity of the transaction cost value compareable to the objective value. The objective value of the ITP with MSTE approach can be formalized as:
$$
 \frac{1}{T} \left\Vert r_{p}-r_{bm} \right\Vert_2^2
$$

## Rebalancing Constraint
asd

## Analyse Objectives
asd

## Complete ITP Example
```{r}
set.seed(0)

train_months <- 4
test_months <- 1
nav <- 20000
 
from <- "2016-01-01"
to <- "2022-10-27"

spx_composition <- buffer(
  get_spx_composition(),
  "AS_spx_composition"
) %>% 
  filter(Date >= from, Date <= to) 
#ticker <- spx_composition$Ticker %>% table() %>% sort(., decreasing = T) %>% .[.>=81] %>% names()

pool_data <- buffer(
  get_yf(
    tickers = spx_composition %>% 
      filter(Date<=to) %>% 
      filter(Date==max(Date)) %>% 
      pull(Ticker), 
    from = from, 
    to = to
  ), 
  "AS_sp500_assets_long"
)


bm_returns_raw <- buffer(
  get_yf(tickers = "^SP500TR", from = from, to = to)$returns,
  "AS_sp500tr_long"
) %>% setNames(., "SP500TR")


rebalance_dates <- data.frame("DATE"=index(pool_data$prices)) %>% 
  mutate(key=substr(DATE, 1, 7)) %>% 
  group_by(key) %>% 
  filter(DATE==min(DATE, na.rm=T)) %>% 
  pull(DATE) %>% 
  sort() %>% 
  c(., as.Date("2022-11-01"))

#rebalance_dates <- rebalance_dates[1:13]

calc_fit <- function(x){
  as.numeric(0.5 * t(x) %*% mat$Dmat %*% x - t(mat$dvec) %*% x + mat$const)
}
calc_const <- function(x){
  const <- t(mat$Amat) %*% x - mat$bvec
  sum(abs(pmin(0, const)))
}

QP_perf <- NULL
QP_infos <- NULL
QP_tickers <- list()
QP_solutions <- list()
for(i in (train_months+1):(length(rebalance_dates)-1)){

  print(i)
  date <- rebalance_dates[i]
  date_from <- rebalance_dates[i-train_months]
  
  train_frame <- paste0(date_from, "/", date)
  test_frame <- paste0(date+1, "/", rebalance_dates[i+test_months])
  
  ticker_in_spx <- spx_composition %>% filter(Date <= date) %>% filter(Date == max(Date)) %>% pull(Ticker)
  ticker_temp <- ticker_in_spx
  
  for(k in c(length(ticker_temp), seq(from=length(ticker_temp)-length(ticker_temp)%%5, to = 100, by=-5))){
    if(k!=length(ticker_temp)){
      ticker_temp <- ticker_temp[ticker_temp %in% names(res_QP$solution %>% sort(., decreasing = T) %>% .[1:k])]
    }
    returns <- pool_data$returns[train_frame, colnames(pool_data$returns) %in% ticker_temp] %>% 
    .[,colSums(is.na(.))==0] %>% 
    .[, colnames(.) %in% names(pool_data$prices[date, colnames(pool_data$prices) %in% ticker_temp]) %>% .[!is.na(.)]]
  
    bm_returns <- bm_returns_raw[train_frame,]
    
    mat <- list(
      Dmat = as.matrix(nearPD(t(returns) %*% returns)$mat),
      dvec = t(returns) %*% bm_returns,
      const = t(bm_returns) %*% bm_returns,
      Amat = t(rbind(
        -rep(1, ncol(returns)), # sum w <= 1
        rep(1, ncol(returns)), # sum w >= 0.99
        diag(1, 
             nrow=ncol(returns), 
             ncol=ncol(returns)), # long only
        diag(-1, 
             nrow=ncol(returns), 
             ncol=ncol(returns)) # smaller than 
      )),
      bvec = c(
        -0.995, # sum w <= 1
        0.96, # sum w >= 0.99
        rep(0, ncol(returns)), # long only
        rep(-0.1, ncol(returns)) # smaller than 
      ),
      meq = 0
    )
  
    res_QP <- solve.QP(
      Dmat = mat$Dmat,
      dvec = mat$dvec,
      Amat = mat$Amat,
      bvec = mat$bvec,
      meq = mat$meq
    )
    res_QP$solution <- setNames(res_QP$solution, colnames(returns))
  }
  
  if(i == (train_months+1)){
    QP_tickers[[i]] <- ticker_temp
    QP_solutions[[i]] <- res_QP$solution[ticker_temp]/sum(res_QP$solution[ticker_temp])
  }else{
    tickers_old <- QP_tickers[[i-1]]
    tickers_new <- ticker_temp[!ticker_temp %in% tickers_old]
    tickers_new <- names(sort(res_QP$solution[tickers_new], decreasing = T) %>% .[1:min(length(.),10)])
    ticker_new <- unique(c(tickers_old, tickers_new))
    
    returns <- pool_data$returns[train_frame, colnames(pool_data$returns) %in% ticker_new] %>% 
    .[,colSums(is.na(.))==0] %>% 
    .[, colnames(.) %in% names(pool_data$prices[date, colnames(pool_data$prices) %in% ticker_temp]) %>% .[!is.na(.)]] %>% 
    .[, !is.na(colnames(.))]
  
    bm_returns <- bm_returns_raw[train_frame,]
    
    mat <- list(
      Dmat = as.matrix(nearPD(t(returns) %*% returns)$mat),
      dvec = t(returns) %*% bm_returns,
      const = t(bm_returns) %*% bm_returns,
      Amat = t(rbind(
        -rep(1, ncol(returns)), # sum w <= 1
        rep(1, ncol(returns)), # sum w >= 0.99
        diag(1, 
             nrow=ncol(returns), 
             ncol=ncol(returns)), # long only
        diag(-1, 
             nrow=ncol(returns), 
             ncol=ncol(returns)) # smaller than 
      )),
      bvec = c(
        -0.995, # sum w <= 1
        0.96, # sum w >= 0.99
        rep(0, ncol(returns)), # long only
        rep(-0.1, ncol(returns)) # smaller than 
      ),
      meq = 0
    )
  
    res_QP <- solve.QP(
      Dmat = mat$Dmat,
      dvec = mat$dvec,
      Amat = mat$Amat,
      bvec = mat$bvec,
      meq = mat$meq
    )
    res_QP$solution <- setNames(res_QP$solution, colnames(returns))
    
    tickers_new <- names(sort(res_QP$solution, decreasing = T)[1:100])
    QP_tickers[[i]] <- tickers_new
    QP_solutions[[i]] <- res_QP$solution[tickers_new]/sum(res_QP$solution[tickers_new])
  }
  
  res_QP$perf <- calc_portfolio_returns(pool_data$returns[test_frame, colnames(returns)], res_QP$solution)
  res_QP$const_break <- calc_const(res_QP$solution)
  
  
  QP_perf <- rbind.xts(
    QP_perf,
    setNames(res_QP$perf, "QP")
  )
  
  QP_infos <- bind_rows(
    QP_infos,
    data.frame(
      "type" = "QP",
      "MSTE_returns" = sum((returns %*% res_QP$solution - bm_returns)^2)
    )
  )

}

save(QP_perf, QP_infos, QP_tickers, QP_solutions, file="analyses/ITP_long_QP_v8.rdata")


rebalance_const <- function(old_wgt, new_wgt, old_shares, new_shares, nav, first_date = F, expo=1, x, returns){
  reblance_wgt <- if(first_date){
    0
  }else{
    sum(abs(old_wgt-new_wgt))/(sum(old_wgt)+sum(new_wgt))
  }
  reblance_fit <- max(reblance_wgt-0.3,0)*100
  tc_return <- sum((new_shares-old_shares)!=0)/nav
  #tc_return <- (1+ 1 * sum((new_shares-old_shares)!=0)/nav)^(6/expo)-1
  #tc_fit <- t(rep(tc_return, nrow(returns))) %*% returns %*% x
  return(reblance_fit + 2*tc_return)
}


MSTE_perf <- NULL
MSTE_infos <- NULL
MSTE_nav <- xts(nav, order.by = rebalance_dates[train_months+1])
portfolio_shares <- setNames(rep(0, ncol(pool_data$returns)), colnames(pool_data$returns))
portfolio_wgts <- setNames(rep(0, ncol(pool_data$returns)), colnames(pool_data$returns))

for(i in (train_months+1):(length(rebalance_dates)-1)){
  save_nav <- MSTE_nav[nrow(MSTE_nav),]
  print(i)
  date <- rebalance_dates[i]
  date_from <- rebalance_dates[i-train_months]
  
  train_frame <- paste0(date_from, "/", date)
  test_frame <- paste0(date+1, "/", rebalance_dates[i+test_months])
  
  ticker_in_spx <- QP_tickers[[i]]#spx_composition %>% filter(Date <= date) %>% filter(Date == max(Date)) %>% pull(Ticker)
  
  returns <- pool_data$returns[train_frame, colnames(pool_data$returns) %in% ticker_in_spx] %>% 
    .[,colSums(is.na(.))==0]
  
  prices <- pool_data$prices[date, colnames(returns)]
  
  bm_returns <- bm_returns_raw[train_frame,]
  
  
  mat <- list(
    Dmat = t(returns) %*% (returns),
    dvec = t(returns) %*% (bm_returns),
    const = t(bm_returns) %*% bm_returns,
    Amat = t(rbind(
      -rep(1, ncol(returns)), # sum w <= 1
      rep(1, ncol(returns)), # sum w >= 0.99
      diag(1, 
           nrow=ncol(returns), 
           ncol=ncol(returns)) # long only
    )),
    bvec = c(
      -0.995, # sum w <= 1
      0.96, # sum w >= 0.99
      rep(0, ncol(returns)) # long only
    ),
    meq = 0
  )
  
  # sell transaction costs because not in S&P anymore
  MSTE_nav[nrow(MSTE_nav),] <- last(MSTE_nav) - 1 * sum(portfolio_shares[!names(portfolio_shares) %in% colnames(returns)]!=0)
  
   
  portfolio_shares_temp <- setNames(portfolio_shares[colnames(returns)], colnames(returns))
  portfolio_shares_temp[is.na(portfolio_shares_temp)] <- 0
  portfolio_wgt_temp <- portfolio_shares_temp * prices / as.numeric(last(MSTE_nav))
  
  
  for(k in 1:80){
    if( k == 1 || res_pso_SAvel_MSTE$const_break > 0 && res_pso_SAvel_MSTE$rebalance_constraint < 0.01 || k < 4){
      res_pso_SAvel_MSTE <- pso_self_adaptive_velocity(
        par = if(k==1){if(i==(train_months+1)){QP_solutions[[i]]}else{portfolio_wgt_temp}}else{res_pso_SAvel_MSTE$solution}, # QP_solutions[[date]]
        fn = function(x){
          shares <- round(x*as.numeric(last(MSTE_nav))/prices)
          x <- as.vector(shares*prices/as.numeric(last(MSTE_nav)))
          fitness <- sqrt(calc_fit(x)/nrow(returns))
          constraints <- calc_const(x)
          rebalance_constraint <- rebalance_const(
            old_wgt = as.vector(portfolio_wgt_temp),
            new_wgt = x,
            old_shares = as.vector(portfolio_shares_temp),
            new_shares = shares,
            nav = as.numeric(last(MSTE_nav)),
            first_date = (i == (train_months+1)),
            expo = nrow(returns),
            x = x, 
            returns = returns
          )
          return(fitness + 100*constraints + rebalance_constraint)
        },
        lower = 0,
        upper = 0.1,
        control = list(
          s = 100, # swarm size
          maxiter = 100 # iterations
        )
      )
      res_pso_SAvel_MSTE$solution <- as.vector(round(res_pso_SAvel_MSTE$solution*as.numeric(last(MSTE_nav))/prices)*prices/as.numeric(last(MSTE_nav)))
      res_pso_SAvel_MSTE$perf <- calc_portfolio_returns(pool_data$returns[test_frame, colnames(returns)], res_pso_SAvel_MSTE$solution)
      res_pso_SAvel_MSTE$fitness <- calc_fit(res_pso_SAvel_MSTE$solution)
      res_pso_SAvel_MSTE$const_break <- calc_const(res_pso_SAvel_MSTE$solution)
      res_pso_SAvel_MSTE$rebalance_constraint <- rebalance_const(
            old_wgt = as.vector(portfolio_wgt_temp),
            new_wgt = res_pso_SAvel_MSTE$solution,
            old_shares = as.vector(portfolio_shares_temp),
            new_shares = round(res_pso_SAvel_MSTE$solution*as.numeric(last(MSTE_nav))/prices),
            nav = as.numeric(last(MSTE_nav)),
            first_date = (i == (train_months+1)),
            expo = nrow(pool_data$returns[test_frame,]),
            x = res_pso_SAvel_MSTE$solution, 
            returns = returns
          )
    }
  }
  
  
  # buy and sell transation costs
  MSTE_nav[nrow(MSTE_nav),] <- last(MSTE_nav) - 1 * sum( (portfolio_shares_temp-round(res_pso_SAvel_MSTE$solution*as.numeric(last(MSTE_nav))/prices))!=0)
  
  
  portfolio_shares <- setNames(as.vector(round(res_pso_SAvel_MSTE$solution*as.numeric(last(MSTE_nav))/prices)), colnames(prices))
  portfolio_wgt <- setNames(as.vector(res_pso_SAvel_MSTE$solution), colnames(prices))
  
  
  MSTE_perf <- rbind.xts(
    MSTE_perf,
    setNames(res_pso_SAvel_MSTE$perf, "PSO_MSTE")
  )
  
  MSTE_infos <- bind_rows(
    MSTE_infos,
    data.frame(
      "type" = "PSO_MSTE",
      "fittness" = res_pso_SAvel_MSTE$fitness,
      "const_break" = res_pso_SAvel_MSTE$const_break,
      "rebalance_constraint" = res_pso_SAvel_MSTE$rebalance_constraint,
      "MSTE_returns" = sum((returns %*% res_pso_SAvel_MSTE$solution - bm_returns)^2),
      "sum_wgt" = sum(portfolio_wgt),
      "min_wgt" = min(portfolio_wgt),
      "n_assets" = sum(portfolio_wgt!=0),
      "rebalance_wgt" = sum(abs(portfolio_wgt_temp-portfolio_wgt))/(sum(portfolio_wgt_temp)+sum(portfolio_wgt)),
      "transaction_costs" = as.numeric(save_nav) - as.numeric(MSTE_nav[nrow(MSTE_nav),])
    )
  )
  
  MSTE_nav <- rbind.xts(MSTE_nav, ret_to_cumret(res_pso_SAvel_MSTE$perf)[-1,]/100 * as.numeric(last(MSTE_nav)))
  
}

save(MSTE_perf, MSTE_infos, MSTE_nav, file="analyses/ITP_long_MSTE_v8.rdata")





# CRT_perf <- NULL
# CRT_infos <- NULL
# CRT_nav <- xts(nav, order.by = rebalance_dates[train_months+1])
# portfolio_shares <- setNames(rep(0, ncol(pool_data$returns)), colnames(pool_data$returns))
# portfolio_wgts <- setNames(rep(0, ncol(pool_data$returns)), colnames(pool_data$returns))
# 
# for(i in (train_months+1):(length(rebalance_dates)-1)){
#   save_nav <- CRT_nav[nrow(CRT_nav),]
#   print(i)
#   date <- rebalance_dates[i]
#   date_from <- rebalance_dates[i-train_months]
#   
#   train_frame <- paste0(date_from, "/", date)
#   test_frame <- paste0(date+1, "/", rebalance_dates[i+test_months])
#   
#   ticker_in_spx <- QP_tickers[[i]] #spx_composition %>% filter(Date <= date) %>% filter(Date == max(Date)) %>% pull(Ticker)
#   
#   returns <- pool_data$returns[train_frame, colnames(pool_data$returns) %in% ticker_in_spx] %>% 
#     .[,colSums(is.na(.))==0]
#   
#   prices <- pool_data$prices[date, colnames(returns)]
#   
#   bm_returns <- bm_returns_raw[train_frame,]
#   
#   mat <- list(
#     #Dmat = t(returns) %*% returns,
#     #dvec = t(returns) %*% bm_returns,
#     Amat = t(rbind(
#       -rep(1, ncol(returns)), # sum w <= 1
#       rep(1, ncol(returns)), # sum w >= 0.99
#       diag(1, 
#            nrow=ncol(returns), 
#            ncol=ncol(returns)) # long only
#     )),
#     bvec = c(
#       -0.995, # sum w <= 1
#       0.96, # sum w >= 0.99
#       rep(0, ncol(returns)) # long only
#     ),
#     meq = 0
#   )
#   
#   
#   
#   
#   # sell transaction costs because not in S&P anymore
#   CRT_nav[nrow(CRT_nav),] <- last(CRT_nav) - 1 * sum(portfolio_shares[!names(portfolio_shares) %in% colnames(returns)]!=0)
#   
#    
#   portfolio_shares_temp <- setNames(portfolio_shares[colnames(returns)], colnames(returns))
#   portfolio_shares_temp[is.na(portfolio_shares_temp)] <- 0
#   portfolio_wgt_temp <- portfolio_shares_temp * prices / as.numeric(last(CRT_nav))
#   
#   
#   for(k in 1:20){
#     if( k == 1 || res_pso_SAvel_CRT$const_break > 0){
#       bm_returns_cumret <- ret_to_cumret(bm_returns)[-1,]
#       res_pso_SAvel_CRT <- pso_self_adaptive_velocity(
#         par = if(k==1){if(i==(train_months+1)){QP_solutions[[i]]}else{portfolio_wgt_temp}}else{res_pso_SAvel_CRT$solution},
#         fn = function(x){
#           shares <- round(x*as.numeric(last(CRT_nav))/prices)
#           x <- as.vector(shares*prices/as.numeric(last(CRT_nav)))
#           fitness <- sqrt(sum((ret_to_cumret(xts(returns %*% x, order.by=index(returns))) - bm_returns_cumret)^2 * 0.994^((nrow(returns)-1):0)))
#           constraints <- calc_const(x)
#           rebalance_constraint <- rebalance_const(
#             old_wgt = as.vector(portfolio_wgt_temp),
#             new_wgt = x,
#             old_shares = as.vector(portfolio_shares_temp),
#             new_shares = shares,
#             nav = as.numeric(last(CRT_nav)),
#             first_date = (i==(train_months+1)),
#             expo = 1
#           )
#           return(fitness+100*constraints+rebalance_constraint)
#         },
#         lower = 0,
#         upper = 0.1,
#         control = list(
#           s = 100, # swarm size
#           maxiter = 100 # iterations
#         )
#       )
#       res_pso_SAvel_CRT$solution <- as.vector(round(res_pso_SAvel_CRT$solution*as.numeric(last(CRT_nav))/prices)*prices/as.numeric(last(CRT_nav)))
#       res_pso_SAvel_CRT$perf <- calc_portfolio_returns(pool_data$returns[test_frame, colnames(returns)], res_pso_SAvel_CRT$solution)
#       res_pso_SAvel_CRT$fitness <- sqrt(sum((ret_to_cumret(xts(returns %*% res_pso_SAvel_CRT$solution, order.by=index(returns))) - bm_returns_cumret)^2 * 0.994^((nrow(returns)-1):0)))
#       res_pso_SAvel_CRT$const_break <- calc_const(res_pso_SAvel_CRT$solution)
#       res_pso_SAvel_CRT$rebalance_constraint <- rebalance_const(
#             old_wgt = as.vector(portfolio_wgt_temp),
#             new_wgt = res_pso_SAvel_CRT$solution,
#             old_shares = as.vector(portfolio_shares_temp),
#             new_shares = round(res_pso_SAvel_CRT$solution*as.numeric(last(CRT_nav))/prices),
#             nav = as.numeric(last(CRT_nav)),
#             expo = 1
#       )
#   
#     }
#   }
#   
#   # buy and sell transation costs
#   CRT_nav[nrow(CRT_nav),] <- last(CRT_nav) - 1 * sum( (portfolio_shares_temp-round(res_pso_SAvel_CRT$solution*as.numeric(last(CRT_nav))/prices))!=0)
#   
#   
#   portfolio_shares <- setNames(as.vector(round(res_pso_SAvel_CRT$solution*as.numeric(last(CRT_nav))/prices)), colnames(prices))
#   portfolio_wgt <- setNames(as.vector(res_pso_SAvel_CRT$solution), colnames(prices))
#   
#   
#   CRT_perf <- rbind.xts(
#     CRT_perf,
#     setNames(res_pso_SAvel_CRT$perf, "SAvel_CRT")
#   )
#   
#   CRT_infos <- bind_rows(
#     CRT_infos,
#     data.frame(
#       "type" = "SAvel_CRT",
#       "fittness" = res_pso_SAvel_CRT$fitness,
#       "const_break" = res_pso_SAvel_CRT$const_break,
#       "rebalance_constraint" = res_pso_SAvel_CRT$rebalance_constraint,
#       "MSTE_returns" = sum((returns %*% res_pso_SAvel_CRT$solution - bm_returns)^2),
#       "sum_wgt" = sum(portfolio_wgt),
#       "min_wgt" = min(portfolio_wgt),
#       "n_assets" = sum(portfolio_wgt!=0),
#       "rebalance_wgt" = sum(abs(portfolio_wgt_temp-portfolio_wgt))/2,
#       "transaction_costs" = as.numeric(save_nav) - as.numeric(CRT_nav[nrow(CRT_nav),])
#     )
#   )
#   
#   CRT_nav <- rbind.xts(CRT_nav, ret_to_cumret(res_pso_SAvel_CRT$perf)[-1,]/100 * as.numeric(last(CRT_nav)))
#   
# }

#save(CRT_perf, CRT_infos, CRT_nav, file="analyses/ITP_long_CRT_v5.rdata")



perf_all <- cbind.xts(
  QP_perf,
  MSTE_perf, 
  setNames(pri_to_ret(MSTE_nav), "PSO_MSTE_TR")#,
  #CRT_perf,
  #setNames(pri_to_ret(CRT_nav), "CRT_TR")
)
perf_all <- cbind.xts(perf_all, bm_returns_raw[paste0(min(index(perf_all)),"/", max(index(perf_all))),])


save.image("analyses/ITP_praxis_v8.rdata")
plotly_line_chart_xts(ret_to_cumret(perf_all))

```







